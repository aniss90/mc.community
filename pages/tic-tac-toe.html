<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="../web/mcco-logo.png">
  <link rel="stylesheet" href="../style/main.css" />
  <link rel="stylesheet" href="../style/tags.css" />
  <title>Tic Tac Toe Game - Friends</title>
  <style>
    @font-face {
      font-family: minecraft;
      src: url('../font/Minecraft-Default.otf');
    }
    @font-face {
      font-family: minecraft-ten;
      src: url('../font/Minecraft-Ten.ttf');
    }
    @font-face {
      font-family: minecraft-five;
      src: url('../font/Minecraft-Five.ttf');
    }

    /* تنسيقات الحقول */
    .user-container {
      display: flex;
      flex-direction: column;
      padding: 10px;
      margin: 10px 0;
      background-color: #262626;
      border-radius: 8px;
      transition: all 0.3s;
      cursor: pointer;
      border: 2px solid #333;
    }

    .user-container:hover {
      background-color: rgba(185, 185, 185, 0.07);
    }

    .user-header {
      display: flex;
      align-items: top;
      gap: 10px;
    }

    .user-avatar {
      border-radius: 10px;
      width: 50px;
      height: 50px;
      object-fit: cover;
        box-shadow:
        0px 0px 14px #565656,
        0 0 0 var(--border-thickness) #1a1a1b,
        0 0 0 0 #1a1a1b; 
    }

    .user-details {
      flex: 1;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .user-name {
      font-weight: bold;
      font-size: 16px;
      color: #FFFFFF;
    }

    .user-info-right {
      text-align: right;
    }

    .points, .fall-tokens {
      display: flex;
      align-items: right;
      font-size: 14px;
      margin: 5px 0;
    }

    .points img, .fall-tokens img {
      margin-right: 5px;
    }

    .fall-tokens {
      color: #E29A2B;
    }

    .user-bio {
      font-size: 12px;
      color: #AAAAAA;
      margin-top: 5px;
      max-width: 200px;
      word-wrap: break-word;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      white-space: normal;
    }

    .action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      justify-content: flex-end;
    }

    .btn {
      padding: 6px 12px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-family: minecraft-five;
      transition: all 0.3s;
    }

    .btn-play {
      background-color: #2196F3;
      color: white;
    }

    .btn-play:hover {
      background-color: #0b7dda;
    }

    .btn-play.cooldown {
      background-color: #666;
      cursor: not-allowed;
    }

    .btn-unfollow {
      background-color: #f44336;
      color: white;
    }

    .btn-unfollow:hover {
      background-color: #da190b;
    }

    /* Modal for stake */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }

    .modal-content {
      background-color: #333;
      margin: 15% auto;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 400px;
      text-align: center;
    }

    .modal input {
      margin: 10px 0;
    }

    /* Game Board */
    #gameContainer {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }

    .game-board {
      display: grid;
      grid-template-columns: repeat(3, 100px);
      grid-template-rows: repeat(3, 100px);
      gap: 5px;
      background: #444;
      padding: 10px;
      border-radius: 8px;
    }

    .cell {
      background: #333;
      border: 2px solid #555;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      cursor: pointer;
      color: white;
    }

    .cell:hover {
      background: #555;
    }

    .player-info {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px;
      padding: 10px;
      background: #333;
      border-radius: 8px;
    }

    .player-timer {
      font-size: 14px;
      color: #FFEB3B;
      margin-left: auto;
    }

    .start-msg {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #4CAF50;
      z-index: 2001;
      display: none;
    }

    #surrenderBtn {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: minecraft-five;
      display: none;
      z-index: 2001;
      margin: 0 20px;
    }

    #surrenderBtn:hover {
      background-color: #da190b;
    }

    /* Notification */
    #gameInviteNotif {
      display: none;
      position: fixed;
      top: -200px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      padding: 15px;
      border-radius: 8px;
      z-index: 1500;
      min-width: 300px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      text-align: center;
      color: #CCCEDD;
    }

    #gameInviteNotif.show {
      animation: slideDown 0.5s forwards;
    }

    #gameInviteNotif.hide {
      animation: slideUp 0.5s forwards;
    }

    @keyframes slideDown {
      to { top: 20px; }
    }

    @keyframes slideUp {
      to { top: -200px; }
    }

    .notif-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
    }

    .btn-accept-invite {
      background: #4CAF50;
      color: white;
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .btn-reject-invite {
      background: #f44336;
      color: white;
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    /* Win popup */
    #winPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      padding: 20px;
      border-radius: 8px;
      z-index: 2500;
      text-align: center;
      width: 80%;
      max-width: 400px;
    }

    /* Other styles from original */
    .tabs {
      display: flex;
      margin-bottom: 15px;
      border-bottom: 2px solid #3D3D3D;
    }

    .tab {
      padding: 10px 20px;
      cursor: pointer;
      color: #A6A6A6;
      transition: all 0.3s;
    }

    .tab.active {
      color: #FFFFFF;
      font-size: 15px;
      border-bottom: 3px solid #929292;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .no-results {
      color: #FF5555;
      padding: 10px;
      font-weight: bold;
      text-align: center;
    }

    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #4CAF50;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      z-index: 10000;
      font-family: minecraft-five;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      display: none;
      min-width: 200px;
      text-align: center;
    }

    .toast.error {
      background-color: #f44336;
    }

    .toast.show {
      display: block;
      animation: fadeInOut 3s ease-in-out;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateX(100%); }
      10% { opacity: 1; transform: translateX(0); }
      90% { opacity: 1; transform: translateX(0); }
      100% { opacity: 0; transform: translateX(100%); }
    }

    .sticky-header {
      position: sticky;
      top: 0;
      z-index: 1000;
      width: 100%;
    }

  </style>
</head>
<body>
  <div class="sticky-header">
    <div class="header">
      <button class="back" id="backButton" type="button" onclick="goBack()"><</button>
      Tic Tac Toe - hub 
      <img src="../icons/friends-9e435.png" height="20">
    </div>
  </div>

  <!-- Toast Notification -->
  <div id="toast" class="toast"></div>

  <!-- Surrender Button -->
  <button id="surrenderBtn" onclick="surrenderGame()">Surrender</button>

  <!-- Game Invite Notification -->
  <div id="gameInviteNotif">
    <div>
      <div style="font-size: 12px; color: #aaa;">Time left: <span id="countdown">10</span>s</div>
      <p id="inviteText"></p>
      <div class="notif-buttons">
        <button class="btn-reject-invite" onclick="rejectInvite()">✘</button>
        <button class="btn-accept-invite" onclick="acceptInvite()">✓</button>
      </div>
    </div>
  </div>

  <!-- Stake Modal -->
  <div id="stakeModal" class="modal">
    <div class="modal-content">
      <h3>Enter Stakes</h3>
      <input type="number" id="coinsStake" min="0" placeholder="Coins (min 500 if used)" />
      <input type="number" id="tokensStake" min="0" placeholder="Fall Tokens (min 5 if used)" />
      <button class="btn btn-play" onclick="sendGameInvite()">Invite to Play</button>
      <button class="btn btn-reject" onclick="closeStakeModal()">Cancel</button>
    </div>
  </div>

  <!-- Game Container -->
  <div id="gameContainer">
    <div style="text-align: center;">
      <div id="opponentInfo" class="player-info"></div>
      <div class="game-board" id="gameBoard"></div>
      <div id="playerInfo" class="player-info"></div>
      <div id="startMsg" class="start-msg"></div>
    </div>
  </div>

  <!-- Win Popup -->
  <div id="winPopup">
    <h2 id="winTitle"></h2>
    <p id="winAmount"></p>
    <button class="btn btn-play" onclick="endGame()">Back to Friends</button>
  </div>

  <div class="content">
    <div class="content-wrapper">
      <div class="left-content">
        <!-- تبويب الأصدقاء -->
        <div class="tab-content active" id="friends-tab">
          <div class="search-container">
            <input type="text" id="friendsSearch" placeholder="Search your friends..." onkeyup="searchFriends()" />
          </div>
          <div id="friendsList">
            <div style="color: white;padding: 5px;"><img src="../icons/loading_spinner.gif" height="15" loading="lazy" /> Loading friends...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
    import { getFirestore, collection, onSnapshot, doc, updateDoc, arrayUnion, arrayRemove, setDoc, getDoc, serverTimestamp, deleteDoc, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBf-HKpI4G5p6E0xP1OHGLxtDTGwE_0gg0",
      authDomain: "minecraft-community-4fd3d.firebaseapp.com",
      projectId: "minecraft-community-4fd3d",
      storageBucket: "minecraft-community-4fd3d.appspot.com",
      messagingSenderId: "550140131027",
      appId: "1:550140131027:web:a5186726cf5372e138c626",
      measurementId: "G-F18SFG2LMZ"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    window.activeUser = localStorage.getItem("activeUser");
    window.friends = [];
    window.friendsData = [];
    window.db = db;
    window.currentTargetUser = null;
    window.currentPlayBtn = null;
    window.inviteCooldown = {};
    window.currentGame = null;
    window.gameDoc = null;
    window.playerSymbol = '';
    window.opponentSymbol = '';
    window.isPlayerTurn = false;
    window.turnTimeout = null;
    window.turnTimerInterval = null;
    window.playerRemainingTime = 90; // 1:30
    window.opponentRemainingTime = 90; // 1:30
    window.userData = {};
    window.opponentData = {};

    // دالة لعرض Toast Notification
    window.showToast = function(message, isError = false) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast ${isError ? 'error' : ''} show`;
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    };

    window.formatPoints = function(num) {
      if (num >= 1_000_000_000_000) return (num / 1_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'T';
      if (num >= 1_000_000_000) return (num / 1_000_000_000).toFixed(1).replace(/\.0$/, '') + 'B';
      if (num >= 1_000_000) return (num / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
      if (num >= 1_000) return (num / 1_000).toFixed(1).replace(/\.0$/, '') + 'k';
      return num.toString();
    };

    // Show stake modal
    window.showStakeModal = function(username, btn) {
      window.currentTargetUser = username;
      window.currentPlayBtn = btn;
      document.getElementById('stakeModal').style.display = 'block';
    };

    window.closeStakeModal = function() {
      document.getElementById('stakeModal').style.display = 'none';
      document.getElementById('coinsStake').value = '';
      document.getElementById('tokensStake').value = '';
      window.currentPlayBtn = null;
    };

    // Send game invite
    window.sendGameInvite = async function() {
      let coinsInput = parseInt(document.getElementById('coinsStake').value) || 0;
      let tokensInput = parseInt(document.getElementById('tokensStake').value) || 0;
      if (coinsInput === 0 && tokensInput === 0) {
        window.showToast('Enter at least one stake (coins or tokens)', true);
        return;
      }
      if (coinsInput > 0 && coinsInput < 500) {
        window.showToast('Minimum 500 coins', true);
        return;
      }
      if (tokensInput > 0 && tokensInput < 5) {
        window.showToast('Minimum 5 fall tokens', true);
        return;
      }
      const targetUser = window.currentTargetUser;
      const inviteId = `${window.activeUser}_${targetUser}`;
      if (window.inviteCooldown[targetUser] && Date.now() - window.inviteCooldown[targetUser] < 5000) {
        window.showToast('Wait 5 seconds before resending', true);
        return;
      }
      try {
        // Check sender's balance
        const userDoc = await getDoc(doc(window.db, "users", window.activeUser));
        if (!userDoc.exists()) {
          window.showToast('User data not found', true);
          return;
        }
        const userData = userDoc.data();
        if (userData.points < coinsInput || userData.fallTokens < tokensInput) {
          window.showToast('Not enough balance to stake', true);
          return;
        }
        await setDoc(doc(window.db, "gameInvites", inviteId), {
          from: window.activeUser,
          to: targetUser,
          coins: coinsInput,
          tokens: tokensInput,
          status: 'pending',
          timestamp: serverTimestamp()
        });
        window.inviteCooldown[targetUser] = Date.now();
        if (window.currentPlayBtn) {
          window.currentPlayBtn.classList.add('cooldown');
          window.currentPlayBtn.textContent = 'Wait 5s';
          setTimeout(() => {
            window.currentPlayBtn.classList.remove('cooldown');
            window.currentPlayBtn.textContent = 'Play';
          }, 5000);
        }
        window.showToast(`Invite sent to ${targetUser}`);
        window.closeStakeModal();
      } catch (error) {
        console.error(error);
        window.showToast('Failed to send invite', true);
      }
    };

    // Listen for incoming invites
    window.listenForInvites = function() {
      const q = query(collection(window.db, "gameInvites"), where("to", "==", window.activeUser), where("status", "==", "pending"));
      onSnapshot(q, (snapshot) => {
        snapshot.forEach((docSnap) => {
          const invite = docSnap.data();
          invite.id = docSnap.id;
          showInviteNotification(invite);
        });
      });
    };

    // Show invite notification
    window.showInviteNotification = function(invite) {
      document.getElementById('inviteText').innerHTML = `${invite.from} wants to play Tic Tac Toe with <br> ${invite.coins} coins & ${invite.tokens} tokens`;
      document.getElementById('countdown').textContent = '10';
      const notif = document.getElementById('gameInviteNotif');
      notif.style.display = 'block';
      notif.classList.add('show');
      window.currentInvite = invite;
      let time = 10;
      const interval = setInterval(() => {
        time--;
        document.getElementById('countdown').textContent = time;
        if (time <= 0) {
          clearInterval(interval);
          notif.classList.remove('show');
          notif.classList.add('hide');
          setTimeout(() => { notif.style.display = 'none'; notif.classList.remove('hide'); }, 500);
        }
      }, 1000);
    };

    // Accept invite
    window.acceptInvite = async function() {
      const invite = window.currentInvite;
      const gameId = invite.id;
      try {
        // Check accepter's balance
        const userDoc = await getDoc(doc(window.db, "users", window.activeUser));
        if (!userDoc.exists()) {
          window.showToast('User data not found', true);
          return;
        }
        const userData = userDoc.data();
        if (userData.points < invite.coins || userData.fallTokens < invite.tokens) {
          window.showToast('Not enough balance to accept', true);
          await updateDoc(doc(window.db, "gameInvites", gameId), { status: 'rejected' });
          hideNotification();
          return;
        }
        await updateDoc(doc(window.db, "gameInvites", gameId), { status: 'accepted' });
        hideNotification();
        startGame(invite.from, invite, 'opponent');
      } catch (error) {
        console.error(error);
        window.showToast('Failed to accept invite', true);
      }
    };

    // Reject invite
    window.rejectInvite = async function() {
      const invite = window.currentInvite;
      await updateDoc(doc(window.db, "gameInvites", invite.id), { status: 'rejected' });
      hideNotification();
    };

    function hideNotification() {
      const notif = document.getElementById('gameInviteNotif');
      if (notif) {
        notif.classList.remove('show');
        notif.classList.add('hide');
        setTimeout(() => { 
          notif.style.display = 'none'; 
          notif.classList.remove('hide'); 
        }, 500);
      }
      window.currentInvite = null;
    }

    // Listen for own invites accepted
    window.listenForOwnInvites = function() {
      const q = query(collection(window.db, "gameInvites"), where("from", "==", window.activeUser), where("status", "==", "accepted"));
      onSnapshot(q, (snapshot) => {
        snapshot.forEach((docSnap) => {
          const invite = docSnap.data();
          invite.id = docSnap.id;
          startGame(invite.to, invite, 'inviter');
        });
      });
    };

    // Check win
    function checkWin(board) {
      const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
      for (let w of wins) {
        if (board[w[0]] && board[w[0]] === board[w[1]] && board[w[0]] === board[w[2]]) {
          return board[w[0]];
        }
      }
      if (board.every(c => c !== '')) return 'draw';
      return null;
    }

    // Get sorted pair name for users
    function getPairFolder(user1, user2) {
      return [user1, user2].sort().join('_');
    }

    // Save match history
    async function saveMatchHistory(gameData, winnerSymbol) {
      const pairFolder = getPairFolder(window.activeUser, window.currentGame.opponent);
      const matchesRef = collection(window.db, "matchHistories", pairFolder, "matches");
      
      // Get current number of matches
      const matchesSnapshot = await getDocs(matchesRef);
      const matchNumber = matchesSnapshot.size + 1;
      const matchId = `#${matchNumber}`;
      
      // Save the match
      await setDoc(doc(matchesRef, matchId), {
        board: gameData.board,
        winner: winnerSymbol,
        stakes: gameData.stakes,
        players: gameData.players,
        timestamp: serverTimestamp()
      });
    }

    // Start game
    window.startGame = async function(opponent, invite, role) {
      if (!window.activeUser) {
        window.showToast('User not logged in', true);
        return;
      }
      window.currentGame = { gameId: invite.id, opponent, coins: invite.coins, tokens: invite.tokens };
      // Fetch user data
      const userDoc = await getDoc(doc(window.db, "users", window.activeUser));
      window.userData = userDoc.data();
      const oppDoc = await getDoc(doc(window.db, "users", opponent));
      window.opponentData = oppDoc.data();
      window.gameDoc = doc(window.db, "games", invite.id);
      document.getElementById('gameContainer').style.display = 'flex';
      document.getElementById('surrenderBtn').style.display = 'block';
      window.playerRemainingTime = 90;
      window.opponentRemainingTime = 90;
      if (role === 'inviter') {
        // Random assign symbols (server-side only)
        const isXFirst = Math.random() > 0.5;
        window.playerSymbol = isXFirst ? 'X' : 'O';
        window.opponentSymbol = isXFirst ? 'O' : 'X';
        const firstTurn = isXFirst ? window.activeUser : opponent;
        const gameData = {
          players: {
            [window.activeUser]: window.playerSymbol,
            [opponent]: window.opponentSymbol
          },
          board: Array(9).fill(''),
          currentTurn: window.playerSymbol,
          currentPlayer: firstTurn,
          stakes: { coins: invite.coins, tokens: invite.tokens },
          status: 'playing',
          startTime: serverTimestamp(),
          turnStartTime: serverTimestamp(),
          times: {
            [window.activeUser]: 90,
            [opponent]: 90
          }
        };
        await setDoc(window.gameDoc, gameData);
        window.currentGame.board = Array(9).fill('');
        window.currentGame.currentTurn = window.playerSymbol;
        window.currentGame.currentPlayer = firstTurn;
        window.currentGame.status = 'playing';
        window.currentGame.times = gameData.times;
        hideNotification();
      }
      // For both roles, start listening
      listenForGameUpdates();
    };

    // Listen for game updates
    window.listenForGameUpdates = function() {
      onSnapshot(window.gameDoc, async (docSnap) => {
        if (docSnap.exists()) {
          const data = docSnap.data();
          // Set symbols if available
          if (data.players) {
            window.playerSymbol = data.players[window.activeUser];
            window.opponentSymbol = data.players[window.currentGame.opponent];
          }
          window.currentGame = { ...window.currentGame, ...data };
          if (window.playerSymbol) {
            renderPlayerInfo();
            renderOpponentInfo();
            renderBoard();
          }
          if (data.status === 'ended') {
            endGameWithResult(data.winner);
            document.getElementById('surrenderBtn').style.display = 'none';
            return;
          }
          // Check for win
          const winner = checkWin(window.currentGame.board);
          if (winner) {
            await updateDoc(window.gameDoc, {status: 'ended', winner: winner === 'draw' ? 'draw' : winner });
            await saveMatchHistory(data, winner);
          }
          // Update local remaining times
          window.playerRemainingTime = data.times[window.activeUser];
          window.opponentRemainingTime = data.times[window.currentGame.opponent];
          // تحديث العداد
          if (data.turnStartTime) {
            const used = Math.floor((Date.now() - data.turnStartTime.toMillis()) / 1000);
            const currentRemaining = data.times[data.currentPlayer] - used;
            if (window.activeUser === data.currentPlayer) {
              window.playerRemainingTime = Math.max(0, currentRemaining);
            } else {
              window.opponentRemainingTime = Math.max(0, currentRemaining);
            }
            if (currentRemaining <= 0) {
              handleTimeout();
            }
          }
          updateTimerDisplay();
        }
      });
    };

    // Render player info with timer
    function renderPlayerInfo() {
      const info = document.getElementById('playerInfo');
      info.innerHTML = `
        <img src="${window.userData.photoURL || '../icons/player-head-128-052ba.png'}" class="user-avatar">
        <div>
          <div>${window.activeUser} playing as ${window.playerSymbol}</div>
          <div class="points"><img src="../icons/coinss_gif.gif" height="12"> ${window.formatPoints(window.userData.points)}</div>
          <div class="fall-tokens"><img src="../icons/fall_token.png" height="12"> ${window.formatPoints(window.userData.fallTokens)}</div>
        </div>
        <div id="playerTimer" class="player-timer"></div>
      `;
    }

    // Render opponent info with timer
    function renderOpponentInfo() {
      const info = document.getElementById('opponentInfo');
      info.innerHTML = `
        <img src="${window.opponentData.photoURL || '../icons/player-head-128-052ba.png'}" class="user-avatar">
        <div>
          <div>${window.currentGame.opponent} playing as ${window.opponentSymbol}</div>
          <div class="points"><img src="../icons/coinss_gif.gif" height="12"> ${window.formatPoints(window.opponentData.points)}</div>
          <div class="fall-tokens"><img src="../icons/fall_token.png" height="12"> ${window.formatPoints(window.opponentData.fallTokens)}</div>
        </div>
        <div id="opponentTimer" class="player-timer"></div>
      `;
    }

    // Render board
    function renderBoard() {
      const boardEl = document.getElementById('gameBoard');
      boardEl.innerHTML = '';
      if (!window.currentGame || !window.currentGame.board) return;
      window.currentGame.board.forEach((cell, i) => {
        const cellEl = document.createElement('div');
        cellEl.className = 'cell';
        cellEl.textContent = cell;
        if (window.currentGame.status === 'playing' && window.currentGame.currentTurn === window.playerSymbol && cell === '') {
          cellEl.onclick = () => makeMove(i);
        }
        boardEl.appendChild(cellEl);
      });
      checkTurn();
    }

    // Make move
    window.makeMove = async function(index) {
      if (!window.currentGame || window.currentGame.board[index] !== '' || window.currentGame.currentTurn !== window.playerSymbol || window.currentGame.status !== 'playing') return;
      clearTimeout(window.turnTimeout);
      clearInterval(window.turnTimerInterval);
      const currentPlayer = window.activeUser;
      const usedTime = Math.floor((Date.now() - window.currentGame.turnStartTime.toMillis()) / 1000);
      const newTime = window.currentGame.times[currentPlayer] - usedTime;
      if (newTime <= 0) {
        handleTimeout();
        return;
      }
      const newBoard = [...window.currentGame.board];
      newBoard[index] = window.playerSymbol;
      const nextTurn = window.playerSymbol === 'X' ? 'O' : 'X';
      const nextPlayer = window.currentGame.opponent;
      const updateData = {
        board: newBoard,
        currentTurn: nextTurn,
        currentPlayer: nextPlayer,
        turnStartTime: serverTimestamp(),
        [`times.${currentPlayer}`]: newTime
      };
      await updateDoc(window.gameDoc, updateData);
    };

    // Check turn and start timer
    function checkTurn() {
      const isMyTurn = window.currentGame.currentTurn === window.playerSymbol;
      window.isPlayerTurn = isMyTurn;
      const startMsg = document.getElementById('startMsg');
      if (isMyTurn && window.currentGame.board.every(cell => cell === '')) {
        startMsg.style.display = 'block';
        startMsg.textContent = 'You Start!';
      } else {
        startMsg.style.display = 'none';
      }
      startTurnTimer(isMyTurn);
    }

    // Start turn timer
    function startTurnTimer(isMyTurn) {
      clearTimeout(window.turnTimeout);
      clearInterval(window.turnTimerInterval);
      if (window.currentGame.status !== 'playing') return;

      let remainingTime = isMyTurn ? window.playerRemainingTime : window.opponentRemainingTime;
      if (remainingTime <= 0) {
        handleTimeout();
        return;
      }

      updateTimerDisplay();

      window.turnTimerInterval = setInterval(() => {
        remainingTime--;
        if (isMyTurn) {
          window.playerRemainingTime = remainingTime;
        } else {
          window.opponentRemainingTime = remainingTime;
        }
        updateTimerDisplay();
        if (remainingTime <= 0) {
          clearInterval(window.turnTimerInterval);
          handleTimeout();
        }
      }, 1000);

      window.turnTimeout = setTimeout(handleTimeout, remainingTime * 1000);
    }

    // Update timer display
    function updateTimerDisplay() {
      const playerTimerEl = document.getElementById('playerTimer');
      const opponentTimerEl = document.getElementById('opponentTimer');
      if (playerTimerEl && opponentTimerEl) {
        const playerMinutes = Math.floor(window.playerRemainingTime / 60);
        const playerSeconds = window.playerRemainingTime % 60;
        const playerTimeStr = `${playerMinutes}:${playerSeconds.toString().padStart(2, '0')}`;
        const opponentMinutes = Math.floor(window.opponentRemainingTime / 60);
        const opponentSeconds = window.opponentRemainingTime % 60;
        const opponentTimeStr = `${opponentMinutes}:${opponentSeconds.toString().padStart(2, '0')}`;
        if (window.currentGame.currentPlayer === window.activeUser) {
          playerTimerEl.textContent = playerTimeStr;
          opponentTimerEl.textContent = opponentTimeStr;
        } else {
          opponentTimerEl.textContent = opponentTimeStr;
          playerTimerEl.textContent = playerTimeStr;
        }
      }
    }

    // Handle timeout (loss for current player)
    async function handleTimeout() {
      if (window.currentGame.status !== 'playing') return;
      const loserSymbol = window.currentGame.currentTurn;
      const winnerSymbol = loserSymbol === 'X' ? 'O' : 'X';
      await updateDoc(window.gameDoc, { status: 'ended', winner: winnerSymbol });
      await saveMatchHistory(window.currentGame, winnerSymbol);
    }

    // Surrender
    window.surrenderGame = async function() {
      if (!confirm('Surrender? You will lose the game.')) return;
      await updateDoc(window.gameDoc, { status: 'ended', winner: window.opponentSymbol });
      await saveMatchHistory(window.currentGame, window.opponentSymbol);
    };

    // End game with result
    async function endGameWithResult(winnerSymbol) {
      if (!window.activeUser || !window.currentGame?.opponent) {
        window.showToast('Error ending game', true);
        window.endGame();
        return;
      }
      let title, amount;
      const stake = window.currentGame.stakes;
      const isWin = winnerSymbol === window.playerSymbol;
      const userRef = doc(window.db, "users", window.activeUser);
      const oppRef = doc(window.db, "users", window.currentGame.opponent);
      try {
        const userDoc = await getDoc(userRef);
        const currentUserData = userDoc.data();
        const currentUserPoints = currentUserData?.points || 0;
        const currentUserTokens = currentUserData?.fallTokens || 0;

        const oppDoc = await getDoc(oppRef);
        const currentOppData = oppDoc.data();
        const currentOppPoints = currentOppData?.points || 0;
        const currentOppTokens = currentOppData?.fallTokens || 0;

        if (winnerSymbol === 'draw') {
          title = 'Draw!';
          amount = 'No change';
        } else if (isWin) {
          title = 'You Won!';
          let changes = [];
          if (stake.coins > 0) changes.push(`+${stake.coins} coins`);
          if (stake.tokens > 0) changes.push(`+${stake.tokens} tokens`);
          amount = changes.length > 0 ? changes.join(' & ') : 'No change';
          await updateDoc(userRef, {
            points: currentUserPoints + stake.coins,
            fallTokens: currentUserTokens + stake.tokens
          });
          await updateDoc(oppRef, {
            points: currentOppPoints - stake.coins,
            fallTokens: currentOppTokens - stake.tokens
          });
        } else {
          title = 'You Lost!';
          let changes = [];
          if (stake.coins > 0) changes.push(`-${stake.coins} coins`);
          if (stake.tokens > 0) changes.push(`-${stake.tokens} tokens`);
          amount = changes.length > 0 ? changes.join(' & ') : 'No change';
          await updateDoc(userRef, {
            points: currentUserPoints - stake.coins,
            fallTokens: currentUserTokens - stake.tokens
          });
          await updateDoc(oppRef, {
            points: currentOppPoints + stake.coins,
            fallTokens: currentOppTokens + stake.tokens
          });
        }
      } catch (error) {
        console.error('Error updating balances:', error);
        window.showToast('Error updating balances', true);
      }
      document.getElementById('winTitle').textContent = title;
      document.getElementById('winAmount').textContent = amount;
      document.getElementById('winPopup').style.display = 'block';
      // Delete game invite and game doc
      try {
        await deleteDoc(doc(window.db, "gameInvites", window.currentGame.gameId));
        await deleteDoc(window.gameDoc);
      } catch (error) {
        console.error('Error deleting docs:', error);
      }
      clearInterval(window.turnTimerInterval);
      clearTimeout(window.turnTimeout);
    }

    // End game
    window.endGame = function() {
      document.getElementById('winPopup').style.display = 'none';
      document.getElementById('gameContainer').style.display = 'none';
      document.getElementById('surrenderBtn').style.display = 'none';
      document.querySelector('.tab-content').style.display = 'block';
      window.loadFriends();
      window.currentGame = null;
      window.playerSymbol = '';
      window.opponentSymbol = '';
    };

    window.unfollow = async function(username) {
      if (!confirm(`Unfollow ${username}?`)) return;
      try {
        await updateDoc(doc(window.db, "users", window.activeUser), {
          friends: arrayRemove(username)
        });
        await updateDoc(doc(window.db, "users", username), {
          friends: arrayRemove(window.activeUser)
        });
        window.showToast("Unfollowed successfully");
        window.loadFriends();
      } catch (error) {
        console.error("Error unfollowing:", error);
        window.showToast("Failed to unfollow", true);
      }
    };

    window.viewProfile = function(username) {
      window.location.href = `selected-user-profile.html?user=${encodeURIComponent(username)}`;
    };

    window.searchFriends = function() {
      const input = document.getElementById("friendsSearch");
      const filter = input.value.toUpperCase();
      const containers = document.querySelectorAll("#friendsList .user-container");
      let found = false;

      containers.forEach(container => {
        const username = container.querySelector('.user-name').textContent;
        const bio = container.querySelector('.user-bio').textContent;
        if (username.toUpperCase().indexOf(filter) > -1 || bio.toUpperCase().indexOf(filter) > -1) {
          container.style.display = "";
          found = true;
        } else {
          container.style.display = "none";
        }
      });

      if (!found) {
        let noResults = document.querySelector("#friendsList .no-results");
        if (!noResults) {
          noResults = document.createElement("div");
          noResults.className = "no-results";
          noResults.textContent = "No matching friends found";
          document.getElementById("friendsList").appendChild(noResults);
        }
      } else {
        const noResults = document.querySelector("#friendsList .no-results");
        if (noResults) noResults.remove();
      }
    };

    window.loadFriends = async function() {
      const friendsList = document.getElementById("friendsList");
      friendsList.innerHTML = '<div style="color: white;padding: 5px;"><img src="../icons/loading_spinner.gif" height="15" loading="lazy" /> Loading friends...</div>';

      try {
        const userDoc = await getDoc(doc(window.db, "users", window.activeUser));
        if (userDoc.exists()) {
          window.friends = userDoc.data().friends || [];

          if (window.friends.length === 0) {
            friendsList.innerHTML = '<div style="color: yellow;padding: 5px;">You don\'t have any friends yet.</div>';
            return;
          }

          window.friendsData = [];
          for (const friendUsername of window.friends) {
            const friendDoc = await getDoc(doc(window.db, "users", friendUsername));
            if (friendDoc.exists()) {
              const friendData = friendDoc.data();
              let bio = friendData.bio || 'No bio available';
              if (bio.length > 100) {
                bio = bio.substring(0, 100) + '...';
              }
              window.friendsData.push({
                username: friendUsername,
                points: friendData.points || 0,
                fallTokens: friendData.fallTokens || 0,
                photoURL: friendData.photoURL,
                tags: friendData.tags || [],
                bio: bio
              });
            }
          }

          window.friendsData.sort((a, b) => b.points - a.points);
          friendsList.innerHTML = '';
          window.friendsData.forEach(friend => {
            window.displayFriend(friend.username, friend.points, friend.fallTokens, friend.photoURL, friend.tags, friend.bio);
          });
        }
      } catch (error) {
        console.error("Error loading friends:", error);
        friendsList.innerHTML = '<div style="color: red;padding: 5px;">Error loading friends.</div>';
        window.showToast("Error loading friends", true);
      }
    };

    window.displayFriend = function(username, points, fallTokens, photoURL, tags = [], bio) {
      const formattedPoints = window.formatPoints(points);
      const formattedFallTokens = window.formatPoints(fallTokens || 0);
      const userImage = photoURL || '../icons/player-head-128-052ba.png';

      let tagsHTML = '';
      if (tags && tags.length > 0) {
        const visibleTags = tags.slice(0, 3);
        const extraCount = tags.length - 3;
        tagsHTML = '<div class="user-tags">';
        visibleTags.forEach(tag => {
          tagsHTML += `<span class="tag tag-${tag}"></span>`;
        });
        if (extraCount > 0) {
          tagsHTML += `<span class="tag more-tags">+${extraCount}</span>`;
        }
        tagsHTML += '</div>';
      }

      const container = `
        <div class="user-container" onclick="viewProfile('${username}')">
          <div class="user-header">
            <img src="${userImage}" alt="${username}" class="user-avatar" loading="lazy">
            <div class="user-details">
              <div>
                <div class="user-name">${username}${tagsHTML}</div>
              </div>
              <div class="user-info-right">
                <div class="points"><img src="../icons/coinss_gif.gif" height="12" loading="lazy"> ${formattedPoints}</div>
                <div class="fall-tokens"><img src="../icons/fall_token.png" height="12" loading="lazy"> ${formattedFallTokens}</div>
                <div class="user-bio">${bio}</div>
              </div>
            </div>
          </div>
          <div class="action-buttons">
            <button class="btn btn-play" onclick="event.stopPropagation(); showStakeModal('${username}', this)">Play</button>
            <button class="btn btn-unfollow" onclick="event.stopPropagation(); unfollow('${username}')">Unfollow</button>
          </div>
        </div>`;
      document.getElementById("friendsList").innerHTML += container;
    };

    document.addEventListener('DOMContentLoaded', async function() {
      if (!window.activeUser) {
        window.showToast("يجب تسجيل الدخول أولاً!", true);
        window.location.href = "login-page.html";
        return;
      }

      window.loadFriends();
      window.listenForInvites();
      window.listenForOwnInvites();

      // Modal close on outside click
      window.onclick = function(event) {
        const modal = document.getElementById('stakeModal');
        if (event.target == modal) {
          window.closeStakeModal();
        }
      }
    });
  </script>

  <script>
    function goBack() {
      if (window.history.length > 1) {
        window.history.back();
      } else {
        window.location.href = '/';
      }
    }
  </script>
</body>
</html>