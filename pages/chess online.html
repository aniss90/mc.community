<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="../web/mcco-logo.png">
  <link rel="stylesheet" href="../style/main.css" />
  <link rel="stylesheet" href="../style/tags.css" />
  <link rel="stylesheet" href="../style/chess-style.css">
  <title>Chess Game - Friends</title>
  <style>
    @font-face {
      font-family: minecraft;
      src: url('../font/Minecraft-Default.otf');
    }
    @font-face {
      font-family: minecraft-ten;
      src: url('../font/Minecraft-Ten.ttf');
    }
    @font-face {
      font-family: minecraft-five;
      src: url('../font/Minecraft-Five.ttf');
    }

    /* User Container */
    .user-container {
      display: flex;
      flex-direction: column;
      padding: 10px;
      margin: 10px 0;
      background-color: #262626;
      border-radius: 8px;
      transition: all 0.3s;
      cursor: pointer;
      border: 2px solid #333;
    }

    .user-container:hover {
      background-color: rgba(185, 185, 185, 0.07);
    }

    .user-header {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .user-avatar {
      border-radius: 10px;
      width: 50px;
      height: 50px;
      object-fit: cover;
      box-shadow: 0px 0px 14px #565656, 0 0 0 2px #1a1a1b;
    }

    .user-details {
      flex: 1;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .user-name {
      font-weight: bold;
      font-size: 16px;
      color: #FFFFFF;
    }

    .user-info-right {
      text-align: right;
    }

    .points, .fall-tokens {
      display: flex;
      align-items: center;
      font-size: 14px;
      margin: 5px 0;
    }

    .points img, .fall-tokens img {
      margin-right: 5px;
    }

    .fall-tokens {
      color: #E29A2B;
    }

    .user-bio {
      font-size: 12px;
      color: #AAAAAA;
      margin-top: 5px;
      max-width: 200px;
      word-wrap: break-word;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      white-space: normal;
    }

    .action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      justify-content: flex-end;
    }

    .btn {
      padding: 6px 12px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-family: minecraft-five;
      transition: all 0.3s;
    }

    .btn-play {
      background-color: #2196F3;
      color: white;
    }

    .btn-play:hover {
      background-color: #0b7dda;
    }

    .btn-play.cooldown {
      background-color: #666;
      cursor: not-allowed;
    }

    .btn-unfollow {
      background-color: #f44336;
      color: white;
    }

    .btn-unfollow:hover {
      background-color: #da190b;
    }

    /* Modal for Stake */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }

    .modal-content {
      background-color: #333;
      margin: 15% auto;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 400px;
      text-align: center;
      color: #FFFFFF;
    }

    .modal input {
      margin: 10px 0;
      padding: 8px;
      width: 80%;
      border-radius: 4px;
      border: 1px solid #555;
      background-color: #444;
      color: #FFFFFF;
    }

    /* Game Board */
    #gameContainer {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    #board {
      border: 6px solid #955713;
      width: 642px;
      height: 642px;
      position: relative;
      max-width: 100vw;
      max-height: 100vh;
      aspect-ratio: 1 / 1;
      box-sizing: border-box;
      display: grid;
      grid-template: repeat(8, 1fr) / repeat(8, 1fr);
    }

    @media screen and (max-width: 642px), (max-height: 642px) {
      #board {
        width: 100%;
        height: auto;
      }
    }

    .player-info {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px;
      padding: 10px;
      background: #333;
      border-radius: 8px;
      color: #FFFFFF;
    }

    .player-timer {
      font-size: 14px;
      color: #FFEB3B;
      margin-left: auto;
    }

    .start-msg {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #4CAF50;
      z-index: 2001;
      display: none;
    }

    #surrenderBtn, #drawBtn {
      position: fixed;
      bottom: 20px;
      padding: 10px 20px;
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: minecraft-five;
      display: none;
      z-index: 2001;
      margin: 0 20px;
    }

    #surrenderBtn:hover {
      background-color: #da190b;
    }

    #drawBtn {
      background-color: #FFC107;
      color: black;
      left: calc(50% + 100px);
      transform: translateX(-50%);
    }

    #surrenderBtn {
      left: calc(50% - 100px);
      transform: translateX(-50%);
    }

    #drawBtn:hover {
      background-color: #FFB300;
    }

    /* Notification */
    #gameInviteNotif {
      display: none;
      position: fixed;
      top: -200px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      padding: 15px;
      border-radius: 8px;
      z-index: 1500;
      min-width: 300px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      text-align: center;
      color: #CCCEDD;
    }

    #gameInviteNotif.show {
      animation: slideDown 0.5s forwards;
    }

    #gameInviteNotif.hide {
      animation: slideUp 0.5s forwards;
    }

    #drawOfferNotif {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      padding: 15px;
      border-radius: 8px;
      z-index: 1500;
      min-width: 300px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      text-align: center;
      color: #CCCEDD;
    }

    #drawOfferNotif.show {
      display: block;
    }

    #drawOfferNotif.hide {
      display: none;
    }

    @keyframes slideDown {
      to { top: 20px; }
    }

    @keyframes slideUp {
      to { top: -200px; }
    }

    .notif-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
    }

    .btn-accept-invite, .btn-accept-draw {
      background: #4CAF50;
      color: white;
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .btn-reject-invite, .btn-reject-draw {
      background: #f44336;
      color: white;
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    /* Win Popup */
    #winPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      padding: 20px;
      border-radius: 8px;
      z-index: 2500;
      text-align: center;
      width: 80%;
      max-width: 400px;
      color: #FFFFFF;
    }

    /* Chess Board Styles */
    .board-flipped {
      transform: rotate(180deg);
    }
    .board-flipped .square {
      transform: rotate(180deg);
    }

    .square {
      background-image: url('../icons/chess-pieces.png');
      background-size: 600% 200%;
      width: 100%;
      height: 100%;
      cursor: pointer;
      z-index: 10;
      position: relative;
      box-sizing: border-box;
    }

    .square.empty {
      background-image: none;
    }

    .square.light {
      background-color: #ffce9e;
    }

    .square.dark {
      background-color: #d18b47;
    }

    .square.selected {
      background-color: #895409;
      z-index: 20;
    }

    .square.black-king { background-position: 0% 100%; }
    .square.black-queen { background-position: 20% 100%; }
    .square.black-bishop { background-position: 40% 100%; }
    .square.black-knight { background-position: 60% 100%; }
    .square.black-rook { background-position: 80% 100%; }
    .square.black-pawn { background-position: 100% 100%; }
    .square.white-king { background-position: 0% 0%; }
    .square.white-queen { background-position: 20% 0%; }
    .square.white-bishop { background-position: 40% 0%; }
    .square.white-knight { background-position: 60% 0%; }
    .square.white-rook { background-position: 80% 0%; }
    .square.white-pawn { background-position: 100% 0%; }

    .square.valid-move::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20%;
      height: 20%;
      background-color: rgba(194, 98, 16, 1);
      border-radius: 50%;
      z-index: 15;
      pointer-events: none;
    }

    .square.king-in-check {
      background-color: #B51818;
      z-index: 20;
    }

    #moveNotation {
      max-width: 300px;
      margin: 10px auto;
      padding: 10px;
      background-color: #9A6937;
      border-radius: 4px;
      max-height: 150px;
      overflow-x: auto;
      white-space: nowrap;
      text-align: left;
      color: #FFFFFF;
    }

    .move-entry {
      display: inline-block;
      margin-right: 10px;
      animation: slideIn 0.3s ease-in;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    #promotionMessage {
      display: none;
      position: fixed;
      z-index: 3000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }

    #promotionMessage.show {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .overlay-inner {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      color: #FFFFFF;
    }

    #promotionList {
      list-style: none;
      padding: 0;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    #promotionList li a {
      background-image: url('../icons/chess-pieces.png');
      background-size: 600% 200%;
      width: 60px;
      height: 60px;
      display: block;
    }

    #promotionList.white li a.queen { background-position: 20% 0%; }
    #promotionList.white li a.rook { background-position: 80% 0%; }
    #promotionList.white li a.bishop { background-position: 40% 0%; }
    #promotionList.white li a.knight { background-position: 60% 0%; }
    #promotionList.black li a.queen { background-position: 20% 100%; }
    #promotionList.black li a.rook { background-position: 80% 100%; }
    #promotionList.black li a.bishop { background-position: 40% 100%; }
    #promotionList.black li a.knight { background-position: 60% 100%; }

    .overlay-title {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .overlay-text {
      margin-bottom: 20px;
    }

    .overlay-button {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border-radius: 4px;
      text-decoration: none;
    }

    /* Tabs and Other UI */
    .tabs {
      display: flex;
      margin-bottom: 15px;
      border-bottom: 2px solid #3D3D3D;
    }

    .tab {
      padding: 10px 20px;
      cursor: pointer;
      color: #A6A6A6;
      transition: all 0.3s;
    }

    .tab.active {
      color: #FFFFFF;
      font-size: 15px;
      border-bottom: 3px solid #929292;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .no-results {
      color: #FF5555;
      padding: 10px;
      font-weight: bold;
      text-align: center;
    }

    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #4CAF50;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      z-index: 10000;
      font-family: minecraft-five;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      display: none;
      min-width: 200px;
      text-align: center;
    }

    .toast.error {
      background-color: #f44336;
    }

    .toast.show {
      display: block;
      animation: fadeInOut 3s ease-in-out;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateX(100%); }
      10% { opacity: 1; transform: translateX(0); }
      90% { opacity: 1; transform: translateX(0); }
      100% { opacity: 0; transform: translateX(100%); }
    }

    .sticky-header {
      position: sticky;
      top: 0;
      z-index: 1000;
      width: 100%;
      background-color: #1a1a1b;
    }

    .header {
      display: flex;
      align-items: center;
      padding: 10px;
      color: #FFFFFF;
      font-family: minecraft-five;
    }

    .back {
      background: none;
      border: none;
      color: #FFFFFF;
      font-size: 20px;
      cursor: pointer;
      margin-right: 10px;
    }
  </style>
</head>
<body>
  <div class="sticky-header">
    <div class="header">
      <button class="back" id="backButton" type="button" onclick="goBack()"><</button>
      Chess - Hub
      <img src="../icons/chess-board-icon.svg" height="20" style="margin-left: 10px;">
    </div>
  </div>

  <!-- Toast Notification -->
  <div id="toast" class="toast"></div>

  <!-- Surrender and Draw Buttons -->
  <button id="surrenderBtn" onclick="surrenderGame()">Surrender</button>
  <button id="drawBtn" onclick="offerDraw()">Offer Draw</button>

  <!-- Game Invite Notification -->
  <div id="gameInviteNotif">
    <div>
      <div style="font-size: 12px; color: #aaa;">Time left: <span id="countdown">10</span>s</div>
      <p id="inviteText"></p>
      <div class="notif-buttons">
        <button class="btn-reject-invite" onclick="rejectInvite()">✘</button>
        <button class="btn-accept-invite" onclick="acceptInvite()">✓</button>
      </div>
    </div>
  </div>

  <!-- Draw Offer Notification -->
  <div id="drawOfferNotif">
    <div>
      <div style="font-size: 12px; color: #aaa;">Time left: <span id="drawCountdown">10</span>s</div>
      <p id="drawText">Your opponent wants a draw</p>
      <div class="notif-buttons">
        <button class="btn-reject-draw" onclick="rejectDraw()">✘</button>
        <button class="btn-accept-draw" onclick="acceptDraw()">✓</button>
      </div>
    </div>
  </div>

  <!-- Stake Modal -->
  <div id="stakeModal" class="modal">
    <div class="modal-content">
      <h3>Enter Stakes</h3>
      <input type="number" id="coinsStake" min="0" placeholder="Coins (min 500 if used)" />
      <input type="number" id="tokensStake" min="0" placeholder="Fall Tokens (min 5 if used)" />
      <button class="btn btn-play" onclick="sendGameInvite()">Invite to Play</button>
      <button class="btn btn-reject" onclick="closeStakeModal()">Cancel</button>
    </div>
  </div>

  <!-- Game Container -->
  <div id="gameContainer">
    <div style="text-align: center;">
      <div id="opponentInfo" class="player-info"></div>
      <section id="board"></section>
      <div id="moveNotation"></div>
      <div id="playerInfo" class="player-info"></div>
      <div id="startMsg" class="start-msg"></div>
    </div>
  </div>

  <!-- Win Popup -->
  <div id="winPopup">
    <h2 id="winTitle"></h2>
    <p id="winAmount"></p>
    <button class="btn btn-play" onclick="endGame()">Back to Friends</button>
  </div>

  <!-- Promotion Message -->
  <div class="overlay" id="promotionMessage">
    <div class="overlay-inner">
      <span class="overlay-title">Promotion!</span>
      <p class="overlay-text" id="alertText">Select a piece for promotion</p>
      <ul id="promotionList" class="white">
        <li><a href="#" class="promotion-button queen" onclick="promote('queen');"></a></li>
        <li><a href="#" class="promotion-button rook" onclick="promote('rook');"></a></li>
        <li><a href="#" class="promotion-button bishop" onclick="promote('bishop');"></a></li>
        <li><a href="#" class="promotion-button knight" onclick="promote('knight');"></a></li>
      </ul>
    </div>
  </div>

  <!-- End Message -->
  <div class="overlay" id="endMessage">
    <div class="overlay-inner">
      <span class="overlay-title">Game Over!</span>
      <p class="overlay-text" id="endText"></p>
      <a href="#" class="overlay-button" onclick="newGame();">New Game</a>
    </div>
  </div>

  <div class="content">
    <div class="content-wrapper">
      <div class="left-content">
        <!-- Friends Tab -->
        <div class="tab-content active" id="friends-tab">
          <div class="search-container">
            <input type="text" id="friendsSearch" placeholder="Search your friends..." onkeyup="searchFriends()" />
          </div>
          <div id="friendsList">
            <div style="color: white; padding: 5px;">
              <img src="../icons/loading_spinner.gif" height="15" loading="lazy" /> Loading friends...
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
    import { getFirestore, collection, onSnapshot, doc, updateDoc, arrayUnion, arrayRemove, setDoc, getDoc, serverTimestamp, deleteDoc, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBf-HKpI4G5p6E0xP1OHGLxtDTGwE_0gg0",
      authDomain: "minecraft-community-4fd3d.firebaseapp.com",
      projectId: "minecraft-community-4fd3d",
      storageBucket: "minecraft-community-4fd3d.appspot.com",
      messagingSenderId: "550140131027",
      appId: "1:550140131027:web:a5186726cf5372e138c626",
      measurementId: "G-F18SFG2LMZ"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Global Variables
    window.activeUser = localStorage.getItem("activeUser");
    window.friends = [];
    window.friendsData = [];
    window.db = db;
    window.currentTargetUser = null;
    window.currentPlayBtn = null;
    window.inviteCooldown = {};
    window.currentGame = null;
    window.gameDoc = null;
    window.playerColor = '';
    window.opponentColor = '';
    window.isPlayerTurn = false;
    window.turnTimerInterval = null;
    window.playerRemainingTime = 600;
    window.opponentRemainingTime = 600;
    window.userData = {};
    window.opponentData = {};
    window.pgn = '';
    window.moveHistory = [];
    window.pieces = [];
    window.boardSquares = [];
    window.selectedSquare = null;
    window.currentCallback = null;
    window.white = new Player("white");
    window.black = new Player("black");
    window.currentPlayer = window.white;
    window.turn = 1;
    window.pendingMove = null;
    let isSettingUpBoard = false;

    // Toast Notification
    window.showToast = function(message, isError = false) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast ${isError ? 'error' : ''} show`;
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    };

    window.formatPoints = function(num) {
      if (num >= 1_000_000_000_000) return (num / 1_000_000_000_000).toFixed(1).replace(/\.0$/, '') + 'T';
      if (num >= 1_000_000_000) return (num / 1_000_000_000).toFixed(1).replace(/\.0$/, '') + 'B';
      if (num >= 1_000_000) return (num / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
      if (num >= 1_000) return (num / 1_000).toFixed(1).replace(/\.0$/, '') + 'k';
      return num.toString();
    };

    // Stake Modal and Invite Functions (unchanged)
    window.showStakeModal = function(username, btn) {
      window.currentTargetUser = username;
      window.currentPlayBtn = btn;
      document.getElementById('stakeModal').style.display = 'block';
    };

    window.closeStakeModal = function() {
      document.getElementById('stakeModal').style.display = 'none';
      document.getElementById('coinsStake').value = '';
      document.getElementById('tokensStake').value = '';
      window.currentPlayBtn = null;
    };

    window.sendGameInvite = async function() {
      let coinsInput = parseInt(document.getElementById('coinsStake').value) || 0;
      let tokensInput = parseInt(document.getElementById('tokensStake').value) || 0;
      if (coinsInput === 0 && tokensInput === 0) {
        window.showToast('Enter at least one stake (coins or tokens)', true);
        return;
      }
      if (coinsInput > 0 && coinsInput < 500) {
        window.showToast('Minimum 500 coins', true);
        return;
      }
      if (tokensInput > 0 && tokensInput < 5) {
        window.showToast('Minimum 5 fall tokens', true);
        return;
      }
      const targetUser = window.currentTargetUser;
      const inviteId = `${window.activeUser}_${targetUser}`;
      if (window.inviteCooldown[targetUser] && Date.now() - window.inviteCooldown[targetUser] < 5000) {
        window.showToast('Wait 5 seconds before resending', true);
        return;
      }
      try {
        const userDoc = await getDoc(doc(window.db, "users", window.activeUser));
        if (!userDoc.exists()) {
          window.showToast('User data not found', true);
          return;
        }
        const userData = userDoc.data();
        if (userData.points < coinsInput || userData.fallTokens < tokensInput) {
          window.showToast('Not enough balance to stake', true);
          return;
        }
        await setDoc(doc(window.db, "gameInvites", inviteId), {
          from: window.activeUser,
          to: targetUser,
          coins: coinsInput,
          tokens: tokensInput,
          status: 'pending',
          timestamp: serverTimestamp()
        });
        window.inviteCooldown[targetUser] = Date.now();
        if (window.currentPlayBtn) {
          window.currentPlayBtn.classList.add('cooldown');
          window.currentPlayBtn.textContent = 'Wait 5s';
          setTimeout(() => {
            window.currentPlayBtn.classList.remove('cooldown');
            window.currentPlayBtn.textContent = 'Play';
          }, 5000);
        }
        window.showToast(`Invite sent to ${targetUser}`);
        window.closeStakeModal();
      } catch (error) {
        console.error('Error sending invite:', error);
        window.showToast('Failed to send invite', true);
      }
    };

    window.listenForInvites = function() {
      const q = query(collection(window.db, "gameInvites"), where("to", "==", window.activeUser), where("status", "==", "pending"));
      onSnapshot(q, (snapshot) => {
        snapshot.forEach((docSnap) => {
          const invite = docSnap.data();
          invite.id = docSnap.id;
          showInviteNotification(invite);
        });
      });
    };

    window.showInviteNotification = function(invite) {
      document.getElementById('inviteText').innerHTML = `${invite.from} wants to play Chess with <br> ${invite.coins} coins & ${invite.tokens} tokens`;
      document.getElementById('countdown').textContent = '10';
      const notif = document.getElementById('gameInviteNotif');
      notif.style.display = 'block';
      notif.classList.add('show');
      window.currentInvite = invite;
      let time = 10;
      const interval = setInterval(() => {
        time--;
        document.getElementById('countdown').textContent = time;
        if (time <= 0) {
          clearInterval(interval);
          rejectInvite();
        }
      }, 1000);
    };

    window.acceptInvite = async function() {
      const invite = window.currentInvite;
      const gameId = invite.id;
      try {
        const userDoc = await getDoc(doc(window.db, "users", window.activeUser));
        if (!userDoc.exists()) {
          window.showToast('User data not found', true);
          return;
        }
        const userData = userDoc.data();
        if (userData.points < invite.coins || userData.fallTokens < invite.tokens) {
          window.showToast('Not enough balance to accept', true);
          await updateDoc(doc(window.db, "gameInvites", gameId), { status: 'rejected' });
          hideNotification();
          return;
        }
        await updateDoc(doc(window.db, "gameInvites", gameId), { status: 'accepted' });
        hideNotification();
        startGame(invite.from, invite, 'opponent');
      } catch (error) {
        console.error('Error accepting invite:', error);
        window.showToast('Failed to accept invite', true);
      }
    };

    window.rejectInvite = async function() {
      const invite = window.currentInvite;
      if (invite) {
        await updateDoc(doc(window.db, "gameInvites", invite.id), { status: 'rejected' });
        hideNotification();
      }
    };

    function hideNotification() {
      const notif = document.getElementById('gameInviteNotif');
      notif.classList.remove('show');
      notif.classList.add('hide');
      setTimeout(() => {
        notif.style.display = 'none';
        notif.classList.remove('hide');
      }, 500);
      window.currentInvite = null;
    }

    window.listenForOwnInvites = function() {
      const q = query(collection(window.db, "gameInvites"), where("from", "==", window.activeUser), where("status", "==", "accepted"));
      onSnapshot(q, (snapshot) => {
        snapshot.forEach((docSnap) => {
          const invite = docSnap.data();
          invite.id = docSnap.id;
          startGame(invite.to, invite, 'inviter');
        });
      });
    };

    function getPairFolder(user1, user2) {
      return [user1, user2].sort().join('_');
    }

    async function saveMatchHistory(gameData, winnerSymbol) {
      const pairFolder = getPairFolder(window.activeUser, window.currentGame.opponent);
      const matchesRef = collection(window.db, "chess-games", pairFolder, "matches");
      const matchesSnapshot = await getDocs(matchesRef);
      const matchNumber = matchesSnapshot.size + 1;
      const matchId = `#${matchNumber}`;
      await setDoc(doc(matchesRef, matchId), {
        pgn: window.pgn,
        winner: winnerSymbol,
        stakes: gameData.stakes,
        players: gameData.players,
        timestamp: serverTimestamp()
      });
    }

    // Start Game with Correct Color and Timer
    window.startGame = async function(opponent, invite, role) {
      if (!window.activeUser) {
        window.showToast('User not logged in', true);
        return;
      }
      window.currentGame = { gameId: invite.id, opponent, coins: invite.coins, tokens: invite.tokens };
      const userDoc = await getDoc(doc(window.db, "users", window.activeUser));
      window.userData = userDoc.data();
      const oppDoc = await getDoc(doc(window.db, "users", opponent));
      window.opponentData = oppDoc.data();
      window.gameDoc = doc(window.db, "games", invite.id);
      document.getElementById('gameContainer').style.display = 'flex';
      document.getElementById('surrenderBtn').style.display = 'block';
      document.getElementById('drawBtn').style.display = 'block';
      window.playerRemainingTime = 600;
      window.opponentRemainingTime = 600;
      if (role === 'inviter') {
        const isWhiteFirst = Math.random() > 0.5;
        window.playerColor = isWhiteFirst ? 'white' : 'black';
        window.opponentColor = isWhiteFirst ? 'black' : 'white';
        const firstTurn = isWhiteFirst ? window.activeUser : opponent;
        const gameData = {
          players: {
            [window.activeUser]: window.playerColor,
            [opponent]: window.opponentColor
          },
          pgn: '',
          currentTurn: 'white', // Always start with White
          currentPlayer: firstTurn,
          stakes: { coins: invite.coins, tokens: invite.tokens },
          status: 'playing',
          startTime: serverTimestamp(),
          turnStartTime: serverTimestamp(),
          times: {
            [window.activeUser]: 600,
            [opponent]: 600
          },
          drawOffer: null
        };
        await setDoc(window.gameDoc, gameData);
        window.currentGame.pgn = '';
        window.currentGame.currentTurn = 'white';
        window.currentGame.currentPlayer = firstTurn;
        window.currentGame.status = 'playing';
        window.currentGame.times = gameData.times;
        hideNotification();
      }
      window.isPlayerTurn = window.playerColor === 'white'; // White starts
      setupBoard();
      startTimer();
      listenForGameUpdates();
    };

    // Listen for Game Updates with Turn Enforcement
  window.listenForGameUpdates = function() {
  onSnapshot(window.gameDoc, async (docSnap) => {
    if (docSnap.exists()) {
      const data = docSnap.data();
      
      // تحديث ألوان اللاعبين
      if (data.players) {
        window.playerColor = data.players[window.activeUser];
        window.opponentColor = data.players[window.currentGame.opponent];
      }
      
      window.currentGame = { ...window.currentGame, ...data };
      
      // تصحيح منطق الدور - يجب أن يكون بناءً على اللون وليس اسم اللاعب فقط
      window.isPlayerTurn = data.currentPlayer === window.activeUser;
      
      if (window.playerColor) {
        renderPlayerInfo();
        renderOpponentInfo();
        
        // قلب اللوحة إذا كان اللاعب أسود
        document.getElementById('board').classList.toggle('board-flipped', window.playerColor === 'black');
        
        // تطبيق PGN الجديد فقط إذا كان مختلفاً
        if (data.pgn !== window.pgn) {
          applyPgnToBoard(data.pgn);
        }
      }
      
      // معالجة نهاية اللعبة
      if (data.status === 'ended') {
        endGameWithResult(data.winner);
        document.getElementById('surrenderBtn').style.display = 'none';
        document.getElementById('drawBtn').style.display = 'none';
        clearInterval(window.turnTimerInterval);
        return;
      }
      
      // التحقق من حالة الملك ضد الملك
      if (isKingVsKing()) {
        await updateDoc(window.gameDoc, { status: 'ended', winner: 'draw' });
        await saveMatchHistory(data, 'draw');
      }
      
      // تحديث التوقيت
      window.playerRemainingTime = data.times[window.activeUser] || 600;
      window.opponentRemainingTime = data.times[window.currentGame.opponent] || 600;
      
      if (data.turnStartTime) {
        const used = Math.floor((Date.now() - data.turnStartTime.toMillis()) / 1000);
        const currentRemaining = data.times[data.currentPlayer] - used;
        
        if (window.activeUser === data.currentPlayer) {
          window.playerRemainingTime = Math.max(0, currentRemaining);
        } else {
          window.opponentRemainingTime = Math.max(0, currentRemaining);
        }
        
        if (currentRemaining <= 0) {
          handleTimeout();
        }
      }
      
      updateTimerDisplay();
      
      // عرض عرض التعادل
      if (data.drawOffer && data.drawOffer.to === window.activeUser && data.drawOffer.status === 'pending') {
        showDrawOfferNotification(data.drawOffer);
      }
    }
  });
};

    // Render Player Info
    function renderPlayerInfo() {
      const info = document.getElementById('playerInfo');
      info.innerHTML = `
        <img src="${window.userData.photoURL || '../icons/player-head-128-052ba.png'}" class="user-avatar">
        <div>
          <div>${window.activeUser} playing as ${window.playerColor}</div>
          <div class="points"><img src="../icons/coinss_gif.gif" height="12"> ${window.formatPoints(window.userData.points)}</div>
          <div class="fall-tokens"><img src="../icons/fall_token.png" height="12"> ${window.formatPoints(window.userData.fallTokens)}</div>
        </div>
        <div id="playerTimer" class="player-timer">${formatTime(window.playerRemainingTime)}</div>
      `;
    }

    // Render Opponent Info
    function renderOpponentInfo() {
      const info = document.getElementById('opponentInfo');
      info.innerHTML = `
        <img src="${window.opponentData.photoURL || '../icons/player-head-128-052ba.png'}" class="user-avatar">
        <div>
          <div>${window.currentGame.opponent} playing as ${window.opponentColor}</div>
          <div class="points"><img src="../icons/coinss_gif.gif" height="12"> ${window.formatPoints(window.opponentData.points)}</div>
          <div class="fall-tokens"><img src="../icons/fall_token.png" height="12"> ${window.formatPoints(window.opponentData.fallTokens)}</div>
        </div>
        <div id="opponentTimer" class="player-timer">${formatTime(window.opponentRemainingTime)}</div>
      `;
    }

    function formatTime(seconds) {
      const min = Math.floor(seconds / 60);
      const sec = seconds % 60;
      return `${min}:${sec < 10 ? '0' : ''}${sec}`;
    }

    // Timer Logic
    function startTimer() {
      clearInterval(window.turnTimerInterval);
      window.turnTimerInterval = setInterval(() => {
        if (window.currentGame.status !== 'playing') {
          clearInterval(window.turnTimerInterval);
          return;
        }
        if (window.isPlayerTurn && window.currentGame.currentTurn === window.playerColor) {
          window.playerRemainingTime = Math.max(0, window.playerRemainingTime - 1);
          updateTimerDisplay();
          if (window.playerRemainingTime <= 0) {
            handleTimeout();
          }
        } else if (!window.isPlayerTurn && window.currentGame.currentTurn === window.opponentColor) {
          window.opponentRemainingTime = Math.max(0, window.opponentRemainingTime - 1);
          updateTimerDisplay();
          if (window.opponentRemainingTime <= 0) {
            handleTimeout();
          }
        }
      }, 1000);
    }

    function updateTimerDisplay() {
      const playerTimer = document.getElementById('playerTimer');
      const opponentTimer = document.getElementById('opponentTimer');
      if (playerTimer) playerTimer.textContent = formatTime(window.playerRemainingTime);
      if (opponentTimer) opponentTimer.textContent = formatTime(window.opponentRemainingTime);
    }

    async function handleTimeout() {
      const winner = window.currentGame.currentPlayer === window.activeUser ? window.opponentColor : window.playerColor;
      await updateDoc(window.gameDoc, { status: 'ended', winner });
      await saveMatchHistory(window.currentGame, winner);
    }

    // Draw Offer
    window.offerDraw = async function() {
      if (confirm('Offer draw?')) {
        await updateDoc(window.gameDoc, {
          drawOffer: {
            from: window.activeUser,
            to: window.currentGame.opponent,
            status: 'pending'
          }
        });
        window.showToast('Draw offered');
      }
    };

    window.showDrawOfferNotification = function(offer) {
      document.getElementById('drawText').innerHTML = `${offer.from} wants a draw`;
      document.getElementById('drawCountdown').textContent = '10';
      const notif = document.getElementById('drawOfferNotif');
      notif.style.display = 'block';
      notif.classList.add('show');
      window.currentDrawOffer = offer;
      let time = 10;
      const interval = setInterval(() => {
        time--;
        document.getElementById('drawCountdown').textContent = time;
        if (time <= 0) {
          clearInterval(interval);
          rejectDraw();
        }
      }, 1000);
    };

    window.acceptDraw = async function() {
      await updateDoc(window.gameDoc, { status: 'ended', winner: 'draw', drawOffer: null });
      await saveMatchHistory(window.currentGame, 'draw');
      hideDrawNotification();
      window.showToast('Draw accepted');
    };

    window.rejectDraw = async function() {
      await updateDoc(window.gameDoc, { drawOffer: null });
      hideDrawNotification();
      window.showToast('Draw rejected');
    };

    function hideDrawNotification() {
      const notif = document.getElementById('drawOfferNotif');
      notif.classList.remove('show');
      notif.classList.add('hide');
      setTimeout(() => {
        notif.style.display = 'none';
        notif.classList.remove('hide');
      }, 500);
      window.currentDrawOffer = null;
    }

    // Chess Logic
    function Player(color) {
      this.checked = false;
      this.color = color;
      this.castled = false;
      this.king = null;
      this.kingMoved = false;
      this.rooksMoved = { left: false, right: false };
      this.promote = null;
      this.moved = null;
    }

    function SquareObject(x, y, color, selected, element, piece) {
      this.x = x;
      this.y = y;
      this.color = color;
      this.element = element;
      this.piece = piece;
      this.selected = selected;
      this.update = function() {
        this.element.className = `square ${this.color}`;
        if (this.selected) {
          this.element.classList.add('selected');
        }
        const pieceClasses = ['white-pawn', 'white-rook', 'white-knight', 'white-bishop', 'white-queen', 'white-king',
                              'black-pawn', 'black-rook', 'black-knight', 'black-bishop', 'black-queen', 'black-king',
                              'empty', 'king-in-check', 'valid-move'];
        pieceClasses.forEach(cls => {
          this.element.classList.remove(cls);
        });
        if (this.piece) {
          this.element.classList.add(`${this.piece.color}-${this.piece.type}`);
          if (this.piece.type === 'king' && this.piece.player.checked) {
            this.element.classList.add('king-in-check');
          }
        } else {
          this.element.classList.add('empty');
        }
      };
      this.setPiece = function(piece) {
        this.piece = piece;
        if (piece) {
          piece.square = this;
          piece.x = this.x;
          piece.y = this.y;
        }
        this.update();
      };
    }

    function Piece(x, y, color, type, player) {
      this.x = x;
      this.y = y;
      this.color = color;
      this.type = type;
      this.player = player;
      this.captured = false;
      this.square = getSquare(x, y);
      this.firstMove = true;
      if (this.square) this.square.setPiece(this);
    }

    function King(x, y, color) {
      Piece.call(this, x, y, color, 'king', color === 'white' ? window.white : window.black);
      this.isValidMove = function(end) {
        const dx = Math.abs(end.x - this.x);
        const dy = Math.abs(end.y - this.y);
        if (dx <= 1 && dy <= 1 && !(dx === 0 && dy === 0)) {
          return { valid: true };
        }
        if (!this.player.kingMoved && dy === 0 && dx === 2 && !this.player.checked) {
          const direction = end.x > this.x ? 'right' : 'left';
          const rookX = direction === 'right' ? 8 : 1;
          const rook = getSquare(rookX, this.y).piece;
          if (rook && rook.type === 'rook' && !this.player.rooksMoved[direction]) {
            const step = direction === 'right' ? 1 : -1;
            for (let x = this.x + step; x !== rookX; x += step) {
              if (getSquare(x, this.y).piece || kingExposedAfterMove(this, getSquare(x, this.y))) {
                return { valid: false };
              }
            }
            return { valid: true, castling: direction };
          }
        }
        return { valid: false };
      };
    }
    King.prototype = Object.create(Piece.prototype);

    function Queen(x, y, color) {
      Piece.call(this, x, y, color, 'queen', color === 'white' ? window.white : window.black);
      this.isValidMove = function(end) {
        const dx = Math.abs(end.x - this.x);
        const dy = Math.abs(end.y - this.y);
        if (dx === 0 || dy === 0 || dx === dy) {
          if (isPathClear(this.square, end)) {
            return { valid: true };
          }
        }
        return { valid: false };
      };
    }
    Queen.prototype = Object.create(Piece.prototype);

    function Rook(x, y, color) {
      Piece.call(this, x, y, color, 'rook', color === 'white' ? window.white : window.black);
      this.isValidMove = function(end) {
        if ((end.x === this.x || end.y === this.y) && isPathClear(this.square, end)) {
          return { valid: true };
        }
        return { valid: false };
      };
    }
    Rook.prototype = Object.create(Piece.prototype);

    function Bishop(x, y, color) {
      Piece.call(this, x, y, color, 'bishop', color === 'white' ? window.white : window.black);
      this.isValidMove = function(end) {
        if (Math.abs(end.x - this.x) === Math.abs(end.y - this.y) && isPathClear(this.square, end)) {
          return { valid: true };
        }
        return { valid: false };
      };
    }
    Bishop.prototype = Object.create(Piece.prototype);

    function Knight(x, y, color) {
      Piece.call(this, x, y, color, 'knight', color === 'white' ? window.white : window.black);
      this.isValidMove = function(end) {
        const dx = Math.abs(end.x - this.x);
        const dy = Math.abs(end.y - this.y);
        if ((dx === 2 && dy === 1) || (dx === 1 && dy === 2)) {
          return { valid: true };
        }
        return { valid: false };
      };
    }
    Knight.prototype = Object.create(Piece.prototype);

    function Pawn(x, y, color) {
      Piece.call(this, x, y, color, 'pawn', color === 'white' ? window.white : window.black);
      this.isValidMove = function(end) {
        const direction = this.color === 'white' ? -1 : 1;
        const startY = this.color === 'white' ? 7 : 2;
        const dx = end.x - this.x;
        const dy = end.y - this.y;
        if (dx === 0 && dy === direction && !end.piece) {
          return { valid: true, promotion: end.y === (this.color === 'white' ? 1 : 8) };
        }
        if (dx === 0 && dy === 2 * direction && this.y === startY && !end.piece && !getSquare(this.x, this.y + direction).piece) {
          return { valid: true };
        }
        if (Math.abs(dx) === 1 && dy === direction && (end.piece || isEnPassant(this, end))) {
          return { valid: true, capture: true, promotion: end.y === (this.color === 'white' ? 1 : 8), enPassant: !end.piece };
        }
        return { valid: false };
      };
    }
    Pawn.prototype = Object.create(Piece.prototype);

    function isPathClear(start, end) {
      const dx = Math.sign(end.x - start.x);
      const dy = Math.sign(end.y - start.y);
      let x = start.x + dx;
      let y = start.y + dy;
      while (x !== end.x || y !== end.y) {
        if (getSquare(x, y).piece) return false;
        x += dx;
        y += dy;
      }
      return true;
    }

    function isEnPassant(pawn, end) {
      if (Math.abs(end.x - pawn.x) === 1 && end.y === pawn.y + (pawn.color === 'white' ? -1 : 1)) {
        const lastMove = window.moveHistory[window.moveHistory.length - 1];
        if (lastMove && lastMove.piece.type === 'pawn' && Math.abs(lastMove.from.y - lastMove.to.y) === 2 && lastMove.to.x === end.x && lastMove.to.y === pawn.y) {
          return true;
        }
      }
      return false;
    }

    function kingExposed(king) {
      const opponentColor = king.color === 'white' ? 'black' : 'white';
      const opponentPieces = window.pieces.filter(p => p.color === opponentColor && !p.captured);
      for (let piece of opponentPieces) {
        const result = piece.isValidMove(king.square);
        if (result.valid && (!result.capture || king.square.piece)) {
          return true;
        }
      }
      return false;
    }

    function kingExposedAfterMove(piece, end) {
      const originalSquare = piece.square;
      const targetPiece = end.piece;
      piece.square.piece = null;
      end.piece = piece;
      piece.x = end.x;
      piece.y = end.y;
      piece.square = end;
      const exposed = kingExposed(piece.player.king);
      piece.x = originalSquare.x;
      piece.y = originalSquare.y;
      piece.square = originalSquare;
      originalSquare.piece = piece;
      end.piece = targetPiece;
      return exposed;
    }

    function getSquare(x, y) {
      const square = window.boardSquares.find(s => s.x === x && s.y === y);
      if (!square) {
        console.warn(`No square found at (${x}, ${y})`);
      }
      return square;
    }

 function setupBoard() {
  if (isSettingUpBoard) {
    console.warn('setupBoard already in progress, skipping');
    return;
  }
  isSettingUpBoard = true;
  
  window.boardSquares = [];
  const boardContainer = document.getElementById("board");
  
  if (!boardContainer) {
    console.error('Board container not found');
    isSettingUpBoard = false;
    return;
  }
  
  // مسح المحتوى القديم
  boardContainer.innerHTML = '';
  
  // إنشاء المربعات
  for (let i = 1; i <= 8; i++) {
    for (let j = 1; j <= 8; j++) {
      let squareElement = document.createElement("div");
      let color = ((i + j) % 2 === 0) ? "light" : "dark";
      
      squareElement.className = `square ${color} empty`;
      squareElement.setAttribute("data-x", j);
      squareElement.setAttribute("data-y", i);
      squareElement.addEventListener("click", squareClicked);
      
      let square = new SquareObject(j, i, color, false, squareElement, null);
      window.boardSquares.push(square);
      boardContainer.appendChild(squareElement);
    }
  }
  
  // إضافة التسميات
  addBoardLabels(boardContainer, window.playerColor === 'black');
  
  // إعادة تعيين القطع
  resetPieces();
  
  forceRenderBoard();
  isSettingUpBoard = false;
}

    function addBoardLabels(board, flipped) {
      const files = flipped ? ['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a'] : ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
      const ranks = flipped ? ['1', '2', '3', '4', '5', '6', '7', '8'] : ['8', '7', '6', '5', '4', '3', '2', '1'];
      for (let i = 0; i < 8; i++) {
        const topLabel = document.createElement('div');
        topLabel.style.position = 'absolute';
        topLabel.style.top = '-20px';
        topLabel.style.left = `${i * 12.5}%`;
        topLabel.style.width = '12.5%';
        topLabel.style.textAlign = 'center';
        topLabel.style.color = '#FFFFFF';
        topLabel.textContent = files[i];
        board.appendChild(topLabel);

        const bottomLabel = document.createElement('div');
        bottomLabel.style.position = 'absolute';
        bottomLabel.style.bottom = '-20px';
        bottomLabel.style.left = `${i * 12.5}%`;
        bottomLabel.style.width = '12.5%';
        bottomLabel.style.textAlign = 'center';
        bottomLabel.style.color = '#FFFFFF';
        bottomLabel.textContent = files[i];
        board.appendChild(bottomLabel);
      }
      for (let i = 0; i < 8; i++) {
        const leftLabel = document.createElement('div');
        leftLabel.style.position = 'absolute';
        leftLabel.style.left = '-20px';
        leftLabel.style.top = `${i * 12.5}%`;
        leftLabel.style.height = '12.5%';
        leftLabel.style.display = 'flex';
        leftLabel.style.alignItems = 'center';
        leftLabel.style.color = '#FFFFFF';
        leftLabel.textContent = ranks[i];
        board.appendChild(leftLabel);

        const rightLabel = document.createElement('div');
        rightLabel.style.position = 'absolute';
        rightLabel.style.right = '-20px';
        rightLabel.style.top = `${i * 12.5}%`;
        rightLabel.style.height = '12.5%';
        rightLabel.style.display = 'flex';
        rightLabel.style.alignItems = 'center';
        rightLabel.style.color = '#FFFFFF';
        rightLabel.textContent = ranks[i];
        board.appendChild(rightLabel);
      }
    }

    function rebuildBoardDOM() {
      const boardContainer = document.getElementById("board");
      if (!boardContainer) return;
      const isFlipped = boardContainer.classList.contains('board-flipped');
      boardContainer.innerHTML = '';
      window.boardSquares.sort((a, b) => (a.y - b.y) * 8 + (a.x - b.x));
      window.boardSquares.forEach(square => {
        const newElement = document.createElement("div");
        newElement.className = `square ${square.color} empty`;
        newElement.setAttribute("data-x", square.x);
        newElement.setAttribute("data-y", square.y);
        newElement.addEventListener("click", squareClicked);
        boardContainer.appendChild(newElement);
        square.element = newElement;
      });
      addBoardLabels(boardContainer, isFlipped);
    }

    function resetPieces() {
      window.pieces = [];
      window.white.king = new King(5, 8, "white");
      window.pieces.push(window.white.king);
      window.pieces.push(new Queen(4, 8, "white"));
      window.pieces.push(new Rook(1, 8, "white"));
      window.pieces.push(new Rook(8, 8, "white"));
      window.pieces.push(new Bishop(3, 8, "white"));
      window.pieces.push(new Bishop(6, 8, "white"));
      window.pieces.push(new Knight(2, 8, "white"));
      window.pieces.push(new Knight(7, 8, "white"));
      for (let i = 1; i <= 8; i++) {
        window.pieces.push(new Pawn(i, 7, "white"));
      }
      window.black.king = new King(5, 1, "black");
      window.pieces.push(window.black.king);
      window.pieces.push(new Queen(4, 1, "black"));
      window.pieces.push(new Rook(1, 1, "black"));
      window.pieces.push(new Rook(8, 1, "black"));
      window.pieces.push(new Bishop(3, 1, "black"));
      window.pieces.push(new Bishop(6, 1, "black"));
      window.pieces.push(new Knight(2, 1, "black"));
      window.pieces.push(new Knight(7, 1, "black"));
      for (let i = 1; i <= 8; i++) {
        window.pieces.push(new Pawn(i, 2, "black"));
      }
      forceRenderBoard();
    }

    function renderBoard() {
      if (!window.boardSquares || window.boardSquares.length === 0) {
        console.warn('boardSquares is empty or undefined, skipping render');
        return;
      }
      const missingElements = window.boardSquares.filter(s => !s.element).length;
      if (missingElements > 0) {
        console.warn(`Missing ${missingElements} elements, rebuilding DOM`);
        rebuildBoardDOM();
      }
      window.boardSquares.forEach(square => square.update());
      updateMoveNotation();
    }

    function forceRenderBoard() {
  if (!window.boardSquares || window.boardSquares.length === 0) {
    console.warn('boardSquares is empty, calling setupBoard');
    setupBoard();
    return;
  }
  renderBoard();
}

    function updateMoveNotation() {
      const notation = document.getElementById('moveNotation');
      if (!notation) return;
      notation.innerHTML = '';
      const moves = parsePgn(window.pgn);
      moves.forEach((move, index) => {
        const moveDiv = document.createElement('div');
        moveDiv.className = 'move-entry';
        moveDiv.textContent = `${index + 1}. ${move.white} ${move.black || ''}`;
        notation.appendChild(moveDiv);
      });
      notation.scrollLeft = notation.scrollWidth;
    }

    function parsePgn(pgn) {
      const moves = [];
      const moveStrings = pgn.trim().split(/\s+/);
      for (let i = 0; i < moveStrings.length; i += 2) {
        moves.push({
          white: moveStrings[i],
          black: moveStrings[i + 1] || ''
        });
      }
      return moves;
    }

   function applyPgnMove(moveText, color) {
  if (!moveText) return false;
  const move = parseMove(moveText, color);
  if (!move) {
    console.warn(`Invalid move text: ${moveText} for ${color}`);
    return false;
  }
  
  const pieces = window.pieces.filter(p => p.type === move.pieceType && p.color === color && !p.captured);
  let startSquare = null;
  let endSquare = getSquare(move.toX, move.toY);
  let moveResult = null; // تعريف moveResult هنا
  
  if (!endSquare) {
    console.warn(`End square not found at (${move.toX}, ${move.toY})`);
    return false;
  }
  
  for (let piece of pieces) {
    const result = piece.isValidMove(endSquare);
    if (result.valid && !kingExposedAfterMove(piece, endSquare)) {
      startSquare = piece.square;
      moveResult = result; // حفظ النتيجة
      break;
    }
  }
  
  if (!startSquare) {
    console.warn(`No valid piece found for move ${moveText}`);
    return false;
  }
  
  // استخدام moveResult بدلاً من result
  movePiece(startSquare, endSquare, { ...moveResult, promotionType: move.promotion });
  return true;
}

    function parseMove(moveText, color) {
      const files = { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8 };
      let pieceType = 'pawn';
      let moveStr = moveText;
      if (moveText.startsWith('O-O')) {
        pieceType = 'king';
        moveStr = moveText === 'O-O' ? (color === 'white' ? 'Kg1' : 'Kg8') : (color === 'white' ? 'Kc1' : 'Kc8');
      } else {
        if (moveText.startsWith('Q')) pieceType = 'queen';
        else if (moveText.startsWith('R')) pieceType = 'rook';
        else if (moveText.startsWith('B')) pieceType = 'bishop';
        else if (moveText.startsWith('N')) pieceType = 'knight';
        else if (moveText.startsWith('K')) pieceType = 'king';
      }
      const to = moveStr.match(/[a-h][1-8]/);
      if (!to) return null;
      const toX = files[to[0][0]];
      const toY = parseInt(to[0][1]);
      const promotion = moveStr.includes('=') ? moveStr.split('=')[1].toLowerCase() : null;
      return { pieceType, toX, toY, promotion };
    }

    function squareClicked(event) {
      if (!window.isPlayerTurn || window.currentGame.currentTurn !== window.playerColor) {
        window.showToast('Not your turn!', true);
        return;
      }
      const square = window.boardSquares.find(s => s.element === event.target);
      if (!square) {
        console.warn('Clicked element not associated with any square');
        return;
      }
      if (window.selectedSquare) {
        if (square === window.selectedSquare) {
          clearSelection();
        } else if (square.piece && square.piece.color === window.currentPlayer.color) {
          selectSquare(square);
        } else {
          window.makeMove(window.selectedSquare, square);
        }
      } else if (square.piece && square.piece.color === window.currentPlayer.color) {
        selectSquare(square);
      }
    }

    function selectSquare(square) {
      clearSelection();
      window.selectedSquare = square;
      square.selected = true;
      square.update();
      const validMoves = getValidMoves(square.piece);
      validMoves.forEach(move => {
        const target = getSquare(move.x, move.y);
        if (target && target.element) target.element.classList.add('valid-move');
      });
    }

    function clearSelection() {
      if (window.selectedSquare) {
        window.selectedSquare.selected = false;
        window.selectedSquare.update();
        window.boardSquares.forEach(square => {
          if (square.element) square.element.classList.remove('valid-move');
        });
        window.selectedSquare = null;
      }
    }

    function getValidMoves(piece) {
      const moves = [];
      for (let x = 1; x <= 8; x++) {
        for (let y = 1; y <= 8; y++) {
          const target = getSquare(x, y);
          if (!target) continue;
          const result = piece.isValidMove(target);
          if (result.valid && !kingExposedAfterMove(piece, target)) {
            moves.push({ x, y });
          }
        }
      }
      return moves;
    }

    window.makeMove = async function(start, end) {
      if (!window.isPlayerTurn || window.currentGame.currentTurn !== window.playerColor) {
        window.showToast('Not your turn!', true);
        clearSelection();
        return;
      }
      const moveResult = start.piece.isValidMove(end);
      if (!moveResult.valid || kingExposedAfterMove(start.piece, end)) {
        window.showToast('Invalid move!', true);
        clearSelection();
        return;
      }
      window.pendingMove = { start, end, moveResult };
      if (moveResult.promotion) {
        document.getElementById('promotionMessage').classList.add('show');
        document.getElementById('promotionList').className = start.piece.color;
      } else {
        await executeMove(start, end, moveResult);
      }
    };

    window.promote = async function(type) {
      document.getElementById('promotionMessage').classList.remove('show');
      const { start, end, moveResult } = window.pendingMove;
      moveResult.promotionType = type;
      await executeMove(start, end, moveResult);
      window.pendingMove = null;
    };

   async function executeMove(start, end, moveResult) {
  const piece = start.piece;
  if (!piece) {
    console.warn(`No piece at start square (${start.x}, ${start.y})`);
    clearSelection();
    return;
  }
  
  let moveText = generateMoveText(start, end, piece, moveResult);
  movePiece(start, end, moveResult);
  
  window.pgn += (window.pgn ? ' ' : '') + moveText;
  
  // تحديد الدور التالي بشكل صحيح
  const nextTurn = window.currentGame.currentTurn === 'white' ? 'black' : 'white';
  const nextPlayer = window.currentGame.currentPlayer === window.activeUser ?
    window.currentGame.opponent : window.activeUser;
  
  const updateData = {
    pgn: window.pgn,
    currentTurn: nextTurn,
    currentPlayer: nextPlayer,
    turnStartTime: serverTimestamp(),
    [`times.${window.activeUser}`]: window.playerRemainingTime,
    drawOffer: null // إزالة أي عرض تعادل عند النقلة
  };
  
  try {
    await updateDoc(window.gameDoc, updateData);
    
    // تحديث حالة اللاعب المحلي
    window.currentPlayer = nextTurn === 'white' ? window.white : window.black;
    window.isPlayerTurn = nextPlayer === window.activeUser;
    
    forceRenderBoard();
    startTimer();
    
    // التحقق من كش ملك
    const opponentPlayer = nextTurn === 'white' ? window.black : window.white;
    if (isCheckmate(opponentPlayer)) {
      const winner = nextTurn; // الفائز هو من قام بالنقلة الأخيرة
      await updateDoc(window.gameDoc, { status: 'ended', winner });
      await saveMatchHistory(window.currentGame, winner);
    }
    
  } catch (error) {
    console.error('Error updating game in Firebase:', error);
    window.showToast('Failed to update move', true);
    // التراجع عن النقلة في الذاكرة المحلية
    movePiece(end, start, { ...moveResult, revert: true });
    window.pgn = window.pgn.replace(new RegExp(`\\s*${moveText}$`), '');
    forceRenderBoard();
  }
  
  clearSelection();
}

    function movePiece(start, end, moveResult) {
      const piece = start.piece;
      if (!piece) {
        console.warn(`No piece at start square (${start.x}, ${start.y})`);
        return;
      }
      if (moveResult.castling) {
        const direction = moveResult.castling;
        const rookX = direction === 'right' ? 8 : 1;
        const rook = getSquare(rookX, piece.y)?.piece;
        const newRookX = direction === 'right' ? end.x - 1 : end.x + 1;
        const rookStartSquare = getSquare(rookX, piece.y);
        const rookEndSquare = getSquare(newRookX, piece.y);
        if (rook && rookStartSquare && rookEndSquare) {
          rookStartSquare.piece = null;
          rookEndSquare.setPiece(rook);
          piece.player.rooksMoved[direction] = true;
          piece.player.castled = true;
        }
      }
      if (moveResult.enPassant) {
        const capturedPawn = getSquare(end.x, start.y)?.piece;
        if (capturedPawn) capturedPawn.captured = true;
      }
      if (end.piece) end.piece.captured = true;
      start.piece = null;
      if (moveResult.promotion && moveResult.promotionType) {
        const NewPiece = { queen: Queen, rook: Rook, bishop: Bishop, knight: Knight }[moveResult.promotionType];
        const newPiece = new NewPiece(end.x, end.y, piece.color);
        window.pieces = window.pieces.filter(p => p !== piece);
        window.pieces.push(newPiece);
        end.setPiece(newPiece);
      } else {
        end.setPiece(piece);
      }
      piece.firstMove = false;
      if (piece.type === 'king') piece.player.kingMoved = true;
      if (piece.type === 'rook') {
        piece.player.rooksMoved[piece.x === 8 ? 'right' : 'left'] = true;
      }
      if (!moveResult.revert) {
        window.moveHistory.push({ piece, from: start, to: end });
      }
      checkForCheck();
      forceRenderBoard();
    }

    function generateMoveText(start, end, piece, moveResult) {
      const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
      let moveText = '';
      if (piece.type === 'king' && moveResult.castling) {
        moveText = moveResult.castling === 'right' ? 'O-O' : 'O-O-O';
      } else {
        const pieceChar = { king: 'K', queen: 'Q', rook: 'R', bishop: 'B', knight: 'N', pawn: '' }[piece.type];
        moveText += pieceChar;
        if (moveResult.capture || moveResult.enPassant) moveText += 'x';
        moveText += files[end.x - 1] + end.y;
        if (moveResult.promotion && moveResult.promotionType) {
          moveText += '=' + moveResult.promotionType.charAt(0).toUpperCase();
        }
      }
      if (isCheckmate(piece.player === window.white ? window.black : window.white)) {
        moveText += '#';
      } else if (kingExposed(piece.player === window.white ? window.black.king : window.white.king)) {
        moveText += '+';
      }
      return moveText;
    }

    function isCheckmate(player) {
      if (!kingExposed(player.king)) return false;
      const pieces = window.pieces.filter(p => p.color === player.color && !p.captured);
      for (let piece of pieces) {
        const moves = getValidMoves(piece);
        if (moves.length > 0) return false;
      }
      return true;
    }

    function checkForCheck() {
      window.white.checked = kingExposed(window.white.king);
      window.black.checked = kingExposed(window.black.king);
      forceRenderBoard();
    }

  function applyPgnToBoard(pgn) {
  if (window.pgn === pgn) return;

  console.log('Applying PGN to board:', pgn);

  const oldMoves = window.pgn.trim().split(/\s+/).filter(Boolean);
  const newMoves = pgn.trim().split(/\s+/).filter(Boolean);

  if (newMoves.length < oldMoves.length) {
    console.warn('New PGN shorter than old, resetting board');
    resetPieces();
    window.pgn = '';
    oldMoves.length = 0; // Clear oldMoves for re-application
  }

  const addedMoves = newMoves.slice(oldMoves.length);
  let color = (oldMoves.length % 2 === 0) ? 'white' : 'black';

  for (const moveText of addedMoves) {
    console.log(`Applying ${color} move: ${moveText}`);
    if (!applyPgnMove(moveText, color)) {
      console.warn(`Failed to apply move: ${moveText} for ${color}`);
    }
    color = color === 'white' ? 'black' : 'white';
  }

  window.pgn = pgn;
  window.currentPlayer = (newMoves.length % 2 === 0) ? window.white : window.black;
  forceRenderBoard();
  updateMoveNotation();
}

    function isKingVsKing() {
      const whitePieces = window.pieces.filter(p => p.color === 'white' && !p.captured);
      const blackPieces = window.pieces.filter(p => p.color === 'black' && !p.captured);
      return whitePieces.length === 1 && blackPieces.length === 1 && 
             whitePieces[0].type === 'king' && blackPieces[0].type === 'king';
    }

    window.surrenderGame = async function() {
      if (confirm('Are you sure you want to surrender?')) {
        const winner = window.playerColor === 'white' ? 'black' : 'white';
        try {
          await updateDoc(window.gameDoc, { status: 'ended', winner });
          await saveMatchHistory(window.currentGame, winner);
          window.showToast('You surrendered the game');
        } catch (error) {
          console.error('Error surrendering game:', error);
          window.showToast('Failed to surrender game', true);
        }
      }
    };

    async function endGameWithResult(winner) {
      clearInterval(window.turnTimerInterval);
      window.turnTimerInterval = null;
      let message = '';
      let amountText = '';
      const coins = window.currentGame.stakes.coins;
      const tokens = window.currentGame.stakes.tokens;
      const totalPot = coins * 2 + tokens * 2 * 1000;
      if (winner === 'draw') {
        message = 'Game ended in a draw!';
        amountText = `You get back ${coins} coins and ${tokens} fall tokens.`;
        await updateUserBalance(window.activeUser, coins, tokens);
        await updateUserBalance(window.currentGame.opponent, coins, tokens);
      } else if (winner === window.playerColor) {
        message = 'You won!';
        amountText = `You won ${totalPot} coins and ${tokens * 2} fall tokens!`;
        await updateUserBalance(window.activeUser, totalPot, tokens * 2);
      } else {
        message = 'You lost!';
        amountText = `You lost ${coins} coins and ${tokens} fall tokens.`;
      }
      document.getElementById('winTitle').textContent = message;
      document.getElementById('winAmount').textContent = amountText;
      document.getElementById('winPopup').style.display = 'block';
      await deleteDoc(doc(window.db, "gameInvites", window.currentGame.gameId));
      await deleteDoc(window.gameDoc);
      window.currentGame = null;
      window.gameDoc = null;
      window.isPlayerTurn = false;
    }

    async function updateUserBalance(username, coins, tokens) {
      try {
        const userRef = doc(window.db, "users", username);
        const userDoc = await getDoc(userRef);
        if (userDoc.exists()) {
          const userData = userDoc.data();
          await updateDoc(userRef, {
            points: userData.points + coins,
            fallTokens: userData.fallTokens + tokens
          });
        }
      } catch (error) {
        console.error('Error updating user balance:', error);
        window.showToast('Failed to update balance', true);
      }
    }

    window.endGame = function() {
      document.getElementById('gameContainer').style.display = 'none';
      document.getElementById('winPopup').style.display = 'none';
      document.getElementById('surrenderBtn').style.display = 'none';
      document.getElementById('drawBtn').style.display = 'none';
      window.pgn = '';
      window.moveHistory = [];
      window.boardSquares = [];
      window.pieces = [];
      window.selectedSquare = null;
      window.currentPlayer = window.white;
      window.turn = 1;
      window.playerRemainingTime = 600;
      window.opponentRemainingTime = 600;
      clearInterval(window.turnTimerInterval);
      window.turnTimerInterval = null;
      loadFriends();
    };

    window.newGame = function() {
      document.getElementById('endMessage').style.display = 'none';
      setupBoard();
    };

    window.loadFriends = async function() {
      try {
        const userDoc = await getDoc(doc(window.db, "users", window.activeUser));
        if (!userDoc.exists()) {
          window.showToast('User data not found', true);
          return;
        }
        window.friends = userDoc.data().friends || [];
        window.friendsData = [];
        const friendsList = document.getElementById('friendsList');
        friendsList.innerHTML = '<div style="color: white; padding: 5px;"><img src="../icons/loading_spinner.gif" height="15" loading="lazy" /> Loading friends...</div>';
        if (window.friends.length === 0) {
          friendsList.innerHTML = '<div class="no-results">No friends found</div>';
          return;
        }
        for (let friend of window.friends) {
          const friendDoc = await getDoc(doc(window.db, "users", friend));
          if (friendDoc.exists()) {
            window.friendsData.push({ username: friend, ...friendDoc.data() });
          }
        }
        renderFriends();
      } catch (error) {
        console.error('Error loading friends:', error);
        window.showToast('Failed to load friends', true);
      }
    };

    function renderFriends() {
      const friendsList = document.getElementById('friendsList');
      friendsList.innerHTML = '';
      if (window.friendsData.length === 0) {
        friendsList.innerHTML = '<div class="no-results">No friends found</div>';
        return;
      }
      window.friendsData.forEach(friend => {
        const userContainer = document.createElement('div');
        userContainer.className = 'user-container';
        userContainer.innerHTML = `
          <div class="user-header">
            <img src="${friend.photoURL || '../icons/player-head-128-052ba.png'}" class="user-avatar">
            <div class="user-details">
              <div class="user-name">${friend.username}</div>
              <div class="user-info-right">
                <div class="points"><img src="../icons/coinss_gif.gif" height="12"> ${window.formatPoints(friend.points)}</div>
                <div class="fall-tokens"><img src="../icons/fall_token.png" height="12"> ${window.formatPoints(friend.fallTokens)}</div>
              </div>
            </div>
          </div>
          <div class="user-bio">${friend.bio || 'No bio available'}</div>
          <div class="action-buttons">
            <button class="btn btn-play" onclick="showStakeModal('${friend.username}', this)">Play</button>
            <button class="btn btn-unfollow" onclick="unfollowFriend('${friend.username}')">Unfollow</button>
          </div>
        `;
        friendsList.appendChild(userContainer);
      });
    }

    window.searchFriends = function() {
      const searchTerm = document.getElementById('friendsSearch').value.toLowerCase();
      const filteredFriends = window.friendsData.filter(friend => friend.username.toLowerCase().includes(searchTerm));
      const friendsList = document.getElementById('friendsList');
      friendsList.innerHTML = '';
      if (filteredFriends.length === 0) {
        friendsList.innerHTML = '<div class="no-results">No friends found</div>';
        return;
      }
      filteredFriends.forEach(friend => {
        const userContainer = document.createElement('div');
        userContainer.className = 'user-container';
        userContainer.innerHTML = `
          <div class="user-header">
            <img src="${friend.photoURL || '../icons/player-head-128-052ba.png'}" class="user-avatar">
            <div class="user-details">
              <div class="user-name">${friend.username}</div>
              <div class="user-info-right">
                <div class="points"><img src="../icons/coinss_gif.gif" height="12"> ${window.formatPoints(friend.points)}</div>
                <div class="fall-tokens"><img src="../icons/fall_token.png" height="12"> ${window.formatPoints(friend.fallTokens)}</div>
              </div>
            </div>
          </div>
          <div class="user-bio">${friend.bio || 'No bio available'}</div>
          <div class="action-buttons">
            <button class="btn btn-play" onclick="showStakeModal('${friend.username}', this)">Play</button>
            <button class="btn btn-unfollow" onclick="unfollowFriend('${friend.username}')">Unfollow</button>
          </div>
        `;
        friendsList.appendChild(userContainer);
      });
    };

    window.unfollowFriend = async function(username) {
      if (confirm(`Unfollow ${username}?`)) {
        try {
          const userRef = doc(window.db, "users", window.activeUser);
          await updateDoc(userRef, {
            friends: arrayRemove(username)
          });
          window.showToast(`Unfollowed ${username}`);
          window.loadFriends();
        } catch (error) {
          console.error('Error unfollowing friend:', error);
          window.showToast('Failed to unfollow friend', true);
        }
      }
    };

    window.goBack = function() {
      window.location.href = '../index.html';
    };

    if (!window.activeUser) {
      window.showToast('Please log in to continue', true);
      setTimeout(() => {
        window.location.href = '../index.html';
      }, 2000);
    } else {
      window.loadFriends();
      window.listenForInvites();
      window.listenForOwnInvites();
    }
  </script> </body> </html>